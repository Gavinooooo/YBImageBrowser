# YBImageBrowser 10分性能优化使用指南

## 🚀 一键优化 (推荐)

最简单的使用方式，适用于大部分场景：

```objective-c
#import "YBImageBrowserPerformance.h"

// 创建浏览器
YBImageBrowser *browser = [YBImageBrowser new];
browser.dataSourceArray = imageDataArray;

// 一键性能优化 - 根据设备自动配置最佳参数
[YBIBPerformanceConfigurator optimizeBrowser:browser 
                                  imageCount:imageDataArray.count 
                             useAdvancedFeatures:YES];

[browser show];
```

## 📱 场景化配置

### 1. 相册浏览模式
```objective-c
// 适用于本地相册图片浏览
[YBIBPerformanceConfigurator configureForPhotoAlbum:browser];
```

### 2. 网络图片浏览模式  
```objective-c
// 适用于网络图片，启用渐进式加载
[YBIBPerformanceConfigurator configureForNetworkImages:browser];
```

### 3. 大图浏览优化
```objective-c
// 针对大图片优化 (averageSize: 平均图片大小MB)
[YBIBPerformanceConfigurator optimizeForLargeImages:browser 
                                  averageImageSizeMB:8.0];
```

### 4. 多图浏览优化
```objective-c
// 针对大量图片优化
[YBIBPerformanceConfigurator optimizeForManyImages:browser 
                                         imageCount:500];
```

### 5. 低性能设备优化
```objective-c
// 针对低配设备优化
[YBIBPerformanceConfigurator optimizeForLowEndDevice:browser];
```

## 🎯 解决您的具体问题

### 问题1: 点击图片到放大打开慢

```objective-c
// 方案1: 启用智能预加载
YBIBSmartPreloader *preloader = [[YBIBSmartPreloader alloc] initWithBrowser:browser];
[preloader startSmartPreloading];

// 方案2: 关闭异步解码，减少等待时间
for (YBIBImageData *data in imageDataArray) {
    data.shouldPreDecodeAsync = NO;  // 同步解码
    data.cuttingZoomScale = 3.0;     // 合理的裁剪阈值
}

// 方案3: 启用渐进式加载
for (YBIBImageData *data in imageDataArray) {
    YBIBProgressiveLoader *loader = [[YBIBProgressiveLoader alloc] initWithImageData:data];
    [loader startProgressiveLoadingWithProgress:^(CGFloat progress) {
        // 显示加载进度
    } completion:^(UIImage *finalImage, NSError *error) {
        // 加载完成
    }];
}
```

### 问题2: 左右切换卡顿

```objective-c
// 方案1: 增加预加载和缓存
browser.preloadCount = 5;  // 增加预加载数量
browser.ybib_imageCache.imageCacheCountLimit = 20;  // 增加缓存

// 方案2: 启用高级缓存系统
YBIBAdvancedImageCache *cache = [YBIBAdvancedImageCache sharedCache];
cache.maxMemoryCacheSizeMB = 200;  // 增加内存缓存
cache.maxDiskCacheSizeMB = 1000;   // 增加磁盘缓存

// 方案3: 启用内存自适应管理
YBIBMemoryAdaptiveManager *memoryManager = [YBIBMemoryAdaptiveManager sharedManager];
[memoryManager registerBrowser:browser];
[memoryManager startMemoryMonitoring];
```

## 💾 高级内存管理

### 自动内存优化
```objective-c
// 启用完整的性能监控和自动优化
[YBIBPerformanceConfigurator enableFullPerformanceMode:browser];

// 内存压力回调
[[YBIBMemoryAdaptiveManager sharedManager] setMemoryPressureHandler:^(YBIBMemoryPressureLevel level) {
    switch (level) {
        case YBIBMemoryPressureLevelWarning:
            NSLog(@"内存警告，系统已自动优化");
            break;
        case YBIBMemoryPressureLevelCritical:
            NSLog(@"内存严重不足，启动紧急优化");
            break;
        case YBIBMemoryPressureLevelUrgent:
            NSLog(@"内存紧急状态，已最小化配置");
            break;
    }
}];
```

### 手动内存控制
```objective-c
// 低内存设备配置
if ([UIDevice currentDevice].physicalMemory < 3 * 1024 * 1024 * 1024) { // < 3GB
    browser.preloadCount = 2;
    browser.ybib_imageCache.imageCacheCountLimit = 6;
    
    // 图片数据优化
    for (YBIBImageData *data in imageDataArray) {
        data.shouldPreDecodeAsync = NO;
        data.cuttingZoomScale = 2.0;
        data.maxZoomScale = 2.0;
    }
}
```

## 📊 性能监控

### 启用性能监控
```objective-c
YBIBPerformanceMonitor *monitor = [YBIBPerformanceMonitor sharedMonitor];
[monitor addBrowserToMonitor:browser];
[monitor startMonitoring];

// 监控回调
dispatch_after(dispatch_time(DISPATCH_TIME_NOW, 10 * NSEC_PER_SEC), dispatch_get_main_queue(), ^{
    NSDictionary *report = [monitor generatePerformanceReport];
    NSLog(@"性能报告: %@", report);
    
    // 获取优化建议
    NSArray *suggestions = [monitor performanceOptimizationSuggestions];
    NSLog(@"优化建议: %@", suggestions);
});
```

### 导出性能数据
```objective-c
// 导出JSON格式数据
NSString *jsonData = [monitor exportPerformanceDataAsJSON];

// 导出CSV格式数据  
NSString *csvData = [monitor exportPerformanceDataAsCSV];
```

## 🔧 自定义配置

### 自定义配置字典
```objective-c
NSDictionary *customConfig = @{
    @"preloadCount": @(4),
    @"cacheCount": @(15),
    @"enableAdvancedFeatures": @(YES),
    @"enablePerformanceMonitoring": @(YES)
};

[YBIBPerformanceConfigurator applyCustomConfiguration:browser config:customConfig];
```

### 批量优化图片数据
```objective-c
// 根据场景批量优化
[YBIBPerformanceConfigurator optimizeImageDatas:imageDataArray 
                                     forScenario:@"network"];

// 智能配置单个图片数据
for (YBIBImageData *data in imageDataArray) {
    [YBIBPerformanceConfigurator smartConfigureImageData:data 
                                                  withURL:data.imageURL];
}
```

## ✅ 配置验证

### 验证当前配置
```objective-c
NSDictionary *validation = [YBIBPerformanceConfigurator validateConfiguration:browser];
NSLog(@"配置验证结果: %@", validation);

if (![validation[@"valid"] boolValue]) {
    NSArray *warnings = validation[@"warnings"];
    NSArray *suggestions = validation[@"suggestions"];
    NSLog(@"警告: %@", warnings);
    NSLog(@"建议: %@", suggestions);
}
```

### 获取配置摘要
```objective-c
NSDictionary *summary = [YBIBPerformanceConfigurator getConfigurationSummary:browser];
NSLog(@"当前配置摘要: %@", summary);
```

## 📈 性能优化效果监控

```objective-c
// 记录图片加载性能
YBIBPerformanceMonitor *monitor = [YBIBPerformanceMonitor sharedMonitor];

// 在图片加载开始时记录
[monitor recordImageLoadStart:imageURL.absoluteString];

// 在图片加载完成时记录
[monitor recordImageLoadComplete:imageURL.absoluteString 
                        loadTime:loadTime 
                         success:YES];

// 记录页面切换性能
[monitor recordPageSwitch:fromPage 
                   toPage:toPage 
               switchTime:switchTime];
```

## 🎨 完整使用示例

```objective-c
#import "YBImageBrowserPerformance.h"

@implementation ViewController

- (void)showOptimizedImageBrowser {
    // 1. 创建图片数据
    NSMutableArray *imageDataArray = [NSMutableArray array];
    for (NSString *imageURL in self.imageURLs) {
        YBIBImageData *data = [YBIBImageData new];
        data.imageURL = [NSURL URLWithString:imageURL];
        data.projectiveView = self.thumbnailViews[i]; // 转场动画起始视图
        [imageDataArray addObject:data];
    }
    
    // 2. 创建浏览器
    YBImageBrowser *browser = [YBImageBrowser new];
    browser.dataSourceArray = imageDataArray;
    browser.currentPage = self.selectedIndex;
    
    // 3. 一键性能优化 (推荐)
    [YBIBPerformanceConfigurator optimizeBrowser:browser 
                                      imageCount:imageDataArray.count 
                                 useAdvancedFeatures:YES];
    
    // 4. 针对您的具体问题进行额外优化
    // 解决打开慢的问题
    for (YBIBImageData *data in imageDataArray) {
        data.shouldPreDecodeAsync = NO;  // 关键优化
    }
    
    // 解决切换卡顿问题
    browser.preloadCount = 5;  // 增加预加载
    browser.ybib_imageCache.imageCacheCountLimit = 20;  // 增加缓存
    
    // 5. 显示浏览器
    [browser show];
}

@end
```

## 💡 性能优化建议总结

1. **立即生效的优化**：
   - 设置 `shouldPreDecodeAsync = NO` 解决打开慢
   - 增加 `preloadCount` 和缓存数量解决切换卡顿

2. **中期优化**：
   - 启用内存自适应管理
   - 使用场景化配置

3. **高级优化**：
   - 启用完整性能监控
   - 使用渐进式加载
   - 自定义优化策略

4. **最佳实践**：
   - 优先使用一键优化
   - 根据实际场景选择配置
   - 定期检查性能报告
   - 针对低配设备特殊优化

通过这套完整的性能优化方案，您的YBImageBrowser将获得显著的性能提升！